#### 1.section
.section 指示把代码划分成若干个段(section), 程序被操作系统加载执行时, 每个段被加载到不同的地址, 操作系统对不同的页面设置不同的读写执行权限.  
.data段保存程序的数据  
.text段保存代码  

#### 2.符号
符号在汇编中代表一个地址, 汇编程序经过汇编器的处理之后, 所有的符号都被替换成它所代表的地址值. 在c语言中, 我们通过函数名调用一个地址, 其实就是跳转到该函数的第一条指令所在的地址.  

#### 3..global
.global指示将符号在目标文件的符号表中标记为一个全局符号. 

#### 4.指令
movl $1, %eax  
这是一条数据传输指令, 在cpu内部产生一个数字1并保存到eax寄存器中. mov后缀l标识为32位的传送指令, $标识立即数. 寄存器名前加%. 同时, 指令的第一个操作数为源操作数, 第二个操作数为目标操作数.  

#### 5.中断
int指令被称为软终端指令, 可以用这条指令故意产生一个异常, 此时cpu从用户模式切换到特权模式, 然后跳转到内核代码中执行异常处理程序. 

#### 6.寻址方式
在访问内存时, 可以通过多种方式表示内存地址. 内存寻址在汇编指令中可以表示成如下的通用格式:  
address_or_offset(%base_or_offset, %index, multiplier)  
它所表示的地址可以这样计算出来:  
final_address = address_or_offset + base_or_offset + multiplier * index  
其中address_or_offset和multiplier必须是常数, 而base_or_offset和index必须是寄存器.  
1. 直接寻址: 只使用address_or_offset寻址, 例如movl ADDRESS, %eax把ADDRESS地址处的32位数传送到eax寄存器  
2. 变址寻址: 例如movl data_items(, %edi, 4), 用于访问数组元素  
3. 间接寻址: 只使用base_or_offset寻址, 例如movl (%eax), %ebx, 把eax寄存器的值看作地址, 把内存中这个地址处的32位数传送到ebx寄存器. 注意和movl %eax, %ebx区分开  
4. 基址寻址: 只使用address_or_offset和base_or_offset寻址, 例如movl 4(%eax), %ebx, 用于访问结构体成员比较方便, 例如一个结构体的基地址保存在eax寄存器中, 其中一个成员在结构体内的偏移量是4字节, 要把这个成员读上来就可以用这条指令  
5. 立即数寻址: 跟寻址没什么关系  
6. 寄存器寻址: 指令中有一个操作数是寄存器. 在汇编程序中寄存器用助记符来表示, 在机器指令中则要用几个bit来表示寄存器的编号, 这几个bit也可以看作寄存器的地址, 但是和内存地址不在一个地址空间  
