#### 1.section
.section 指示把代码划分成若干个段(section), 程序被操作系统加载执行时, 每个段被加载到不同的地址, 操作系统对不同的页面设置不同的读写执行权限.  
.data段保存程序的数据  
.text段保存代码  
.shstrtab段保存着各section的名字
.strtab段保存着程序中用到的符号的名字. 每个名字都是以"\0"结尾的字符串
c语言的全局变量如果在代码中没有初始化, 就会在程序加载时用0初始化. 这种数据属于.bss段, 在加载时它和.data段一样都是可读可写的数据, 但是在elf文件中.data段需要占用一部分空间保存初始值, 而.bss则不需要. 也就是说, .bss段在文件中只占一个section header而没有对应的section, 程序加载时.bss段占多大内存空间在section header中描述  
.rel.text告诉链接器指令中的哪些地方需要做重定位.  
.symtab是符号表.  

#### 2.符号
符号在汇编中代表一个地址, 汇编程序经过汇编器的处理之后, 所有的符号都被替换成它所代表的地址值. 在c语言中, 我们通过函数名调用一个地址, 其实就是跳转到该函数的第一条指令所在的地址.  

#### 3..global
.global指示将符号在目标文件的符号表中标记为一个全局符号. 

#### 4.指令
movl $1, %eax  
这是一条数据传输指令, 在cpu内部产生一个数字1并保存到eax寄存器中. mov后缀l标识为32位的传送指令, $标识立即数. 寄存器名前加%. 同时, 指令的第一个操作数为源操作数, 第二个操作数为目标操作数.  

#### 5.中断
int指令被称为软终端指令, 可以用这条指令故意产生一个异常, 此时cpu从用户模式切换到特权模式, 然后跳转到内核代码中执行异常处理程序. 

#### 6.寻址方式
在访问内存时, 可以通过多种方式表示内存地址. 内存寻址在汇编指令中可以表示成如下的通用格式:  
address_or_offset(%base_or_offset, %index, multiplier)  
它所表示的地址可以这样计算出来:  
final_address = address_or_offset + base_or_offset + multiplier * index  
其中address_or_offset和multiplier必须是常数, 而base_or_offset和index必须是寄存器.  
1. 直接寻址: 只使用address_or_offset寻址, 例如movl ADDRESS, %eax把ADDRESS地址处的32位数传送到eax寄存器  
2. 变址寻址: 例如movl data_items(, %edi, 4), 用于访问数组元素  
3. 间接寻址: 只使用base_or_offset寻址, 例如movl (%eax), %ebx, 把eax寄存器的值看作地址, 把内存中这个地址处的32位数传送到ebx寄存器. 注意和movl %eax, %ebx区分开  
4. 基址寻址: 只使用address_or_offset和base_or_offset寻址, 例如movl 4(%eax), %ebx, 用于访问结构体成员比较方便, 例如一个结构体的基地址保存在eax寄存器中, 其中一个成员在结构体内的偏移量是4字节, 要把这个成员读上来就可以用这条指令  
5. 立即数寻址: 跟寻址没什么关系  
6. 寄存器寻址: 指令中有一个操作数是寄存器. 在汇编程序中寄存器用助记符来表示, 在机器指令中则要用几个bit来表示寄存器的编号, 这几个bit也可以看作寄存器的地址, 但是和内存地址不在一个地址空间  

#### 7.寄存器
x86-64一共有16个64位寄存器, 分别是: %rax, %rbx, %rcx, %rdx, %esi, %edi, %rbp, %rsp, %r8, %r9, %r10, %r11, %r12, %r13, %r14, %r15. 其中:  
%rax作为函数返回值使用.  
%rsp作为栈指针寄存器, 指向栈顶.  
%rbp作为栈指针寄存器, 指向栈底. 且在函数调用过程中不会改变.  
%rdi, %rsi, %rdx, %rcx, %r8, %r9用作函数参数.  
%rbx, %rbq, %r12, %r13, %r14, %r15用作数据存储, 遵循被调用者使用原则.  
%r10, %r11用作数据存储, 遵循调用这使用原则.  
%rip寄存器用来保存下一条指令的地址.  

#### 8.栈帧结构
c语言属于面向过程语言, 他最大特点就是把一个程序分解成若干过程(函数), 比如: 入口函数就是main, 然后调用各个子函数. 在对应的机器语言中, gcc把过程转化成栈帧(frame), 简单的说, 每个栈帧对应一个过程.  

#### 9.体系结构基础
现代计算机基于von neumann体系结构, 这种结构的主要特点是: cpu和内存是计算机的两个主要组成部分, 内存中保存这数据和指令, cpu从内存中取指令执行.   
每个内存单元都有一个地址, 内存地址是从0开始编号的整数, cpu通过地址找到相应的内存单元, 取其中的指令或者读写其中的数据. int, float等多字节的数据类型保存在内存中要占用连续的多个地址, 这种情况下数据的地址是它所占内存单元的起始地址.  

#### 10.cpu
cpu总是从内存取地址, 执行, 然后再取下一条地址. cpu最核心的功能单元包括:  
* 寄存器: 是cpu内部的高速存储器, 像内存一样可以存取数据, 但比访问内存快得多.  
* 程序计数器(PC):　是一种特殊寄存器, 保存着cpu取下一条指令的地址, cpu按照程序计数器保存的地址去内存中取指令然后解释执行, 这时程序计数器保存的地址会自动加上该指令的长度, 指向内存中的下一条指令.  
* 算术逻辑单元(ALU): 如果译码器将一条指令解释为运算指令, 就调用算术逻辑单元去做运算, 比如加减乘除, 位运算, 逻辑运算. 指令中会指示运算结果保存到哪里, 可能保存到寄存器中, 也可能保存到内存中.  
* 地址和数据总线(BUS): CPU和内存之间用地址总线 数据总线和控制线连接起来, 每条线上有1和0两种状态. 如果在执行指令过程中需要访问内存, 比如从内存读一个数到寄存器,执行过程可以想象成这样:  
    1. CPU内部将寄存器对接到数据总线上, 使寄存器的每以为对接到一条数据线, 等待接收数据.  
    2. CPU通过控制线发一个读请求, 并且将内存地址通过地址线发给内存.  
    3. 内存收到地址和读请求之后, 将相应的内存单元对接到数据总线的另一端, 这样, 内存单元的每一位的1或者0状态通过一条数据线到达CPU寄存器中相应的位, 就完成了数据传送.  

#### 11.32位与64位
指的是CPU处理器的字长, 32位的CPU其寄存器和BUS也是32位的, 可以访问的地址空间从0x00000000-0xffffffff, 共4GB, 而64位计算机有更大的地址空间.  

#### 12.设备
CPU执行指令除了访问内存之外还要访问很多设备. 有些设备像内存芯片一样连接到处理器的地址总线和数据总线上, 不同的设备和内存芯片应该占不同的地址范围, 访问这种设备就像访问内存一样, 按地址读写即可. 设备中可供读写访问的单元通常称为设备寄存器, 操作设备的过程就是读写这些设备寄存器的过程.  
还有一些设备集成在处理器芯片中. 无论是在CPU外部接总线的设备还是在CPU内部接总线的设备都有各自的地址范围, 都可以想访问内存一样访问, 很多体系结构(比如ARM)采用这种方式操作设备, 称为内存映射I/O. 而x86对于设备有独立的端口地址空间, CPU核需要引出额外的地址线来连接片内地址(和访问内存所用的地址线不同), 访问设备寄存器时采用特殊的in/out指令, 而不是和访问内存用同样的指令, 这种方式称为端口I/O.  
从CPU的角度看, 访问设备只有内存映射I/O和端口I/O两种, 要么像内存一样访问, 要么用一种专用的指令访问. 对于不同设备的性能要求, 出现了不同的设备总线, 比如PCI, AGP, USB, SATA等, 这些设备总线并不直接和CPU相连, CPU通过内存映射I/O或端口I/O访问相应的总线控制器, 通过总线控制器再取访问挂在总线上的设备.  
在x86平台上, 硬盘是挂在IDE, SATA或者SCSI总线上的设备, 保存在硬盘上的程序是不能被CPU直接取指令执行的, 操作系统在执行程序时会把它从硬盘拷贝到内存, 这样CPU才能取指令执行, 这个过程称为加载(LOAD). 程序加载到内存后, 成为操作系统调度执行的一个任务, 就称为进程(process). 进程和程序不是一一对应的. 一个程序可以多次加载到内存, 称为同时运行的多个进程.  
操作系统本身也是保存在磁盘上的程序, 计算机在启动时执行一段固定的启动代码首先将操作系统从磁盘加载到内存, 然后执行操作系统中的代码把用户需要的其他程序加载到内存. 操作系统是常驻内存的, 最核心的功能是管理进程调度, 管理内存的分配使用以及管理各种设备.  
访问设备还有一点和访问内存不同. 内存只保存数据而不会产生新的数据, 如果CPU不去读它, 它也不需要主动提供数据给CPU, 所以内存总是被动地等待读写. 而设备会自己产生数据, 并且需要主动通知CPU来读这些数据, 例如从键盘输入. 此时需要中断机制. 每个设备都有一条中断线, 通过中断控制器连接到CPU, 当设备需要主动通知CPU时就引发一个中断信号, CPU正在执行的指令将被打断, 程序计数器会指向某个固定的地址(由体系结构定义), 于是CPU从这个地址开始取指令, 执行中断服务程序(ISR), 完成中断处理之后再返回先前被打断的地方执行后续指令.  
由于各种设备的操作方式各不相同, 每个设备都需要专门的设备驱动程序. 设备驱动程序通常是内核里的一组函数, 通过读写设备寄存器实现对设备的初始化, 读, 写等操作, 有些设备还要提供一个中断处理函数供ISR调用.  

#### 13.MMU内存管理单元
如果处理器没有MMU, CPU执行单元发出的内存地址将直接传到芯片引脚上, 被内存芯片接收, 这称为物理地址(PA).  
如果处理其启用MMU, CPU执行单元发出的内存地址将被MMU截获, 从CPU到MMU的地址chegnwie虚拟地址(VA), 而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上, 也就是将VA映射成PA.  
通常操作系统把虚拟地址空间划分为用户空间和内核空间, 例如x86平台的linux系统虚拟地址空间是0x00000000~0xffffffff, 前3GB(0x00000000~0xbfffffff)是用户空间, 后1GB(0xc0000000~0xffffffff)是内核空间. 用户程序加载到用户空间, 在用户模式下执行, 不能访问内核中的数据, 也不能跳转到内核代码中执行. 这样可以保护内核. CPU在产生终端或异常时不仅会跳转到终端或异常服务程序, 还会自动切换模式, 从用户模式切换到特权模式, 因此从中断或异常服务程序可以跳转到内核代码执行.  

#### 14.段错误
段错误是这样产生的:  
1. 用户程序要访问的一个VA, 经MMU检查无权访问.  
2. MMU产生一个异常, CPU从用户模式切换到特权模式, 跳转到内核代码中执行异常服务程序.  
3. 内核把这个异常解释为段错误, 把引发异常的进程终止掉.  

#### 15.elf文件
elf文件格式是一个开放标准, 各种unix系统的可执行文件都采用elf格式, 它有三种不同的类型:  
1. 可重定位的目标文件(object file)
2. 可执行文件
3. 共享库

#### 16.链接过程
汇编器读取源码转化成目标文件max.o, 目标文件由若干个section组成, 我们在汇编程序中声明的.section会成为目标文件中的section, 此外汇编器还会自动添加一些section.  
然后链接器把目标文件中的section合并为几个segment, 生成可执行文件.  
最后加载器根据可执行文件中的segment信息加载运行这个程序.  

#### 17.elf
目标文件需要链接器做进一步处理, 所以一定有section header table; 可执行文件需要加载执行, 所以一定有program header table; 而共享库既要加载运行, 又要在加载时做动态链接, 所以两者都有.  

#### 18.跳转指令
跳转指令中指定的是相对于当前指令向前或向后跳多少字节, 而不是指定一个完整的内存地址, 内存地址有32位, 而跳转指令只有16位, 只能在当前指令前后的一个小范围内跳转.  

#### 19.函数调用过程(x86-32平台)
在执行程序时, 操作系统为进程分配一块栈空间来保存函数栈帧, esp寄存器总是指向栈顶, 在x86平台上这个栈是从高地址向低地址增长的, 每次调用一个函数都要分配一个栈帧来保存参数和局部变量.  
esp和ebp寄存器保存的是函数栈的顶和底的地址.  
1. 首先保存参数, 将参数保存在esp+4, esp指向的内存位置, 然后执行call指令.  
2. call指令有两个作用: 首先将call的下一条指令压栈(执行push命令时, 栈顶指针esp自动减4, 然后再将数据存入esp当前指向的地址); 修改程序计数器eip, 跳转到调用函数的开头执行.  

#### 20.函数调用
每个函数中的局部变量只能在其内部使用, 不能在其他函数内部调用.  
全局变量保存在内存上, 而局部变量保存在函数帧栈上. 全局变量通过一个寄存器rip进行寻址访问, 而局部变量通过栈底指针寄存器rbp进行寻址访问